# Data Model: NeonDB Integration for Todo List App

## Overview
This document defines the data models for the todo list application when integrated with NeonDB (PostgreSQL). The models maintain compatibility with existing functionality while optimizing for PostgreSQL features.

## Entity Definitions

### Task
**Description**: Represents a todo item in the system

**Fields**:
- `id`: Integer (Primary Key, Auto-increment)
  - Unique identifier for the task
  - Auto-generated by the database
- `title`: String (Variable length, max 255 characters)
  - Required field containing the task title
  - Cannot be null or empty
- `description`: Text (Optional, nullable)
  - Optional detailed description of the task
  - Can be null if no description is provided
- `is_completed`: Boolean
  - Indicates whether the task is completed (true) or pending (false)
  - Default value: false
- `created_at`: DateTime (Timestamp with timezone)
  - Timestamp when the task was created
  - Auto-populated by the database
- `updated_at`: DateTime (Timestamp with timezone)
  - Timestamp when the task was last updated
  - Auto-updated whenever the task is modified

**Validation Rules**:
- Title must not be empty or whitespace-only
- Title length must be between 1-255 characters
- Created_at and updated_at must be valid timestamps

**State Transitions**:
- Pending (is_completed = false) → Completed (is_completed = true)
- Completed (is_completed = true) → Pending (is_completed = false)

**Indexes**:
- Primary Index: id (automatically created)
- Secondary Index: created_at (for sorting by creation date)
- Secondary Index: is_completed (for filtering by completion status)

### TaskList
**Description**: Virtual collection representing all tasks (not stored separately)

**Relationships**:
- Contains multiple Task entities
- Provides aggregation and querying capabilities for tasks

## Database Schema (PostgreSQL-specific)

```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    is_completed BOOLEAN DEFAULT FALSE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- Indexes
CREATE INDEX idx_tasks_created_at ON tasks(created_at);
CREATE INDEX idx_tasks_is_completed ON tasks(is_completed);
CREATE INDEX idx_tasks_title ON tasks(title);

-- Trigger to update updated_at on modification
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_tasks_updated_at
    BEFORE UPDATE ON tasks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

## Migration Considerations

### From SQLite to PostgreSQL
- Column types need conversion (INTEGER PRIMARY KEY AUTOINCREMENT → SERIAL PRIMARY KEY)
- Text type mapping (TEXT remains TEXT in PostgreSQL)
- Timestamp handling (DATETIME in SQLite maps to TIMESTAMP WITH TIME ZONE in PostgreSQL)
- Boolean type mapping (INTEGER in SQLite maps to BOOLEAN in PostgreSQL)

### Data Integrity
- All existing constraints should be maintained
- Foreign key relationships preserved (none in current schema)
- Default values properly defined for PostgreSQL

## API Compatibility
- Field names remain unchanged to maintain API compatibility
- Data types converted appropriately between Python and PostgreSQL
- Validation rules preserved across the transition